////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2022 - 2023.
//    Haixing Hu, Qubit Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
const token = '%[a-f0-9]{2}';
const singleMatcher = new RegExp(`(${token})|([^%]+?)`, 'gi');
const multiMatcher = new RegExp(`(${token})+`, 'gi');

function decodeComponents(components, split) {
  try {
    // Try to decode the entire string first
    return [decodeURIComponent(components.join(''))];
  } catch {
    // Do nothing
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  // Split the array in 2 parts
  const left = components.slice(0, split);
  const right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch {
    let tokens = input.match(singleMatcher) || [];
    for (let i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join('');
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}

function customDecodeURIComponent(input) {
  // Keep track of all the replacements and prefill the map with the `BOM`
  const replaceMap = {
    '%FE%FF': '\uFFFD\uFFFD',
    '%FF%FE': '\uFFFD\uFFFD',
  };
  let match = multiMatcher.exec(input);
  while (match) {
    try {
      // Decode as big chunks as possible
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch {
      const result = decode(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
  replaceMap['%C2'] = '\uFFFD';
  const entries = Object.keys(replaceMap);
  for (const key of entries) {
    // Replace all decoded components
    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  }
  return input;
}

function decodeUriComponentEx(encodedURI) {
  if (typeof encodedURI !== 'string') {
    throw new TypeError(`Expected \`encodedURI\` to be of type \`string\`, got \`${typeof encodedURI}\``);
  }
  try {
    // Try the builtin decoder first
    return decodeURIComponent(encodedURI);
  } catch {
    // Fallback to a more advanced decoder
    return customDecodeURIComponent(encodedURI);
  }
}

/**
 * 对URL编码字符串进行解码。
 *
 * 此函数是个增强型的`decodeURIComponent`函数，相比原生的`decodeURIComponent`函数，主要改进如下：
 *
 * - 把 BOM 转换为替换字符 `�`
 * - 对于非法的URI输入字符，不抛出异常；
 * - 尽可能多地解码字符
 * - 对`+`号当做空格处理，因为服务器端和表单都把空格转换为`+`号。
 *
 * 此函数的实现参考了开源代码库<a href="https://github.com/SamVerschueren/decode-uri-component">decode-uri-component</a>.
 *
 * @param {String} str
 *   待解码的URL编码字符串。
 * @return {String}
 *   解码结果。
 * @author 胡海星
 * @see <a href="https://github.com/SamVerschueren/decode-uri-component">decode-uri-component</a>
 */
function uriDecode(str) {
  if (str === null || str === undefined) {
    throw new TypeError(`Expected \`str\` to be of type \`string\`, got \`${typeof str}\``);
  }
  // The + character is interpreted as a space on the server side as well as
  // generated by forms with spaces in their fields.
  return decodeUriComponentEx(str.replace(/\+/g, ' '));
}

export default uriDecode;
export { decodeUriComponentEx };
